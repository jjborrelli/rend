---
title: "rend: An R package for Ecological Network Dynamics"
author: "Jonathan J. Borrelli"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  pdf_document:
    fig_caption: yes
    number_sections: yes
    toc: yes
  fontsize: 12pt
  geometry: margin=1in
---
```{r, message = F, echo = F, warning = F}
library(knitr)
opts_chunk$set(tidy = T, message = F, warning = F, echo = F, comment = NA)
library(rend)
library(ggplot2)
library(data.table)
```

\begin{center}
\Large{\bf{Abstract:}}\\
\normalsize
Abstract text goes here
\end{center}

# Introduction  

While there is an abundance of packages available in the R programming environment to analyze the structure of networks (e.g., igraph, foodweb, sna, enar, cheddar), there is a dearth of packages that can be used to apply dynamic models to the interacting populations.   

In this paper I present an in-development R package for the simulation and analysis of ecological network dynamics. The package is still in-development because the current version limits the user to the simulation of food web (trophic) dynamics. Future versions will incorporate additional functionality (discussed below).


#	Overview  

## Food Web Dynamics Simulation  

###	Consumer-Resource Model

A bioenergetics consumer resource model is at the core of the food web dynamics simulator function. The model was originally developed for two species by Yodzis and Ines (CITATION), generalized to multiple species by Mcann et al. (CITATION). The version included in this version of rend is was first presented in Williams and Martinez (CITATION) and used again in Romanuk et al. (CITATION).


\begin{align}
\frac{dB_i(t)}{dt} = G_i(B) - x_iB_i(t) + \sum_{j}^{n}\left(x_i y_{ij} F_{ij}(B) B_i(t) - x_j y_{ji} F_{ji}(B) B_j(t) / e_{ji} \right)
\end{align}

There are four basic parts to the model: growth, death, consumption of prey, and being consumed by predators. The first term, $G_i(B)$, is the function describing primary production of producer species in the absence of predation. Producers grow exponentially with density dependence.   

\begin{align}
G_i(B) = r_i B_i(t) (1 - \frac{B_i(t)}{K_i})
\end{align}

In the equation, $r_i$ is the intrinsic rate of increase, $B_i$ is the biomass of population _i_, and $K_i$ is the carrying capacity of population _i_. The consumption of resource _j_ by consumer _i_ is modeled by:     

\begin{align}
F_{Hij}(B) = \frac{B_j^{1+q}}{\sum_k B_k^{1+q} + B_0^{1+q}}
\end{align}

Here, $B_j$ is the biomass of the consumed resource, in the denominator the summed biomass across all $k$ resources, and $B_0$ is the half saturation density. The parameter $q$ is a tuning parameter that lets the modeller shift the functional response between a type II ($q = 0$) and a type III ($q = 1$). The functional response above defines the fraction of a predator's maximal ingestion that is realized at a given time step (Figure 1).

```{r Fijsim}

K = 1
x.i = .5
yij = 6
xpar = 0
B.o = .5
A =  matrix(c(0,0,1,0), nrow = 2)
FR = Fij

prey <- seq(0, 2, .01)
pred <- .5
x <- c(0, .5, 1, 3, 5)
eaten <- matrix(nrow = length(prey), ncol = length(x))
for(j in 1:length(x)){
  for(i in 1:length(prey)){
    states = c(prey[i], pred)
    eaten[i,j] <- rowSums((x.i * yij * FR(states, A, B.o, xpar = x[j]) * states))[2]
  }
}

d1 <- list()
for(i in 1:ncol(eaten)){
  d1[[i]] <- cbind(eat = eaten[,i], q = x[i], prey)
}
d2 <- do.call(rbind, d1)
```

```{r FRfig, fig.height = 5, fig.width = 6, fig.cap = "How the functional response of the prey changes with altered values of the parameter q"}
ggplot(as.data.frame(d2), aes(x = prey, y = eat, col = factor(q))) + geom_line(size = 1.5) + xlab("Prey Biomass") + ylab("Prey Biomass Consumed") + 
  theme_bw() + labs(col = "q")
```

In this model, the impact of the predator on the prey is equivalent to the impact of the prey on the predator. Thus the numerical response of the predator is the same magnitude as the functional response of the prey but of the opposite sign. This is accomplished as $F_ji = t(F_ij)$.


An alternative functional response is based on consumer interference (Beddington DeAngelis CITATION).   

\begin{align}
F_{BDij}(B) = \frac{B_j}{\sum_{k=1}^n \alpha_{ik}B_k(t) + (1+c_{ij}B_i(t))B_{0ji}}
\end{align} 

Here the parameter $c_{ij}$ gives the strength of the interference. Figure 2 shows how $c_{ij}$ changes the shape of the functional response.     

```{r Fbdsim}

K = 1
x.i = .5
yij = 6
xpar = 0
B.o = .5
A =  matrix(c(0,0,1,0), nrow = 2)
FR = Fbd

prey <- seq(0, 2, .01)
pred <- .5
x <- c(0, .5, 1, 3, 5)
eaten <- matrix(nrow = length(prey), ncol = length(x))
for(j in 1:length(x)){
  for(i in 1:length(prey)){
    states = c(prey[i], pred)
    eaten[i,j] <- rowSums((x.i * yij * FR(states, A, B.o, xpar = x[j]) * states))[2]
  }
}

d1 <- list()
for(i in 1:ncol(eaten)){
  d1[[i]] <- cbind(eat = eaten[,i], q = x[i], prey)
}
d2 <- do.call(rbind, d1)
```

```{r FRfig2, fig.height = 5, fig.width = 6, fig.cap = "How the functional response of the prey changes with altered values of the parameter c"}
ggplot(as.data.frame(d2), aes(x = prey, y = eat, col = factor(q))) + geom_line(size = 1.5) + xlab("Prey Biomass") + ylab("Prey Biomass Consumed") + 
  theme_bw() + labs(col = "c")
```  

###	Implementation  

The model is implemented in the code as a numerical integration using the deSolve R package (CITATION). Currently, the primary function is `CRsimulator`, which allows the user to specify all parameter values and the desired functions for the growth of basal species and the functional response. Inputs to `CRsimulator` are described in Table 1. 

```{r table1, results = "asis"}
df <- data.frame(Parameter = factor(c("Adj", "t", "G", "method", "FuncRes", "K", "x.i", "yij", "eij", "xpar", "B.o", "ext", "plot")),
                 Definition = c("Adjacency matrix",
                                "Sequence of time steps",
                                "Function for basal resource growth",
                                "Function to input into the ode solver",
                                "Functional response",
                                "Carrying capacity",
                                "Mass specific metabolic rate",
                                "Maximum rate at which species i assimilates specesi j per unit metabolic rate of species i",
                                "Conversion efficiency",
                                "Tuning parameter either q or c depending on the functional response",
                                "Half saturation density of species j when consumed by species i",
                                "Function describing extinction events during the simulation",
                                "Whether or not to generate a plot of biomass against time"))
kable(df, format = "pandoc", caption = "Parameter definitions for the dynamic model")
```

The `CRsimulator` function can be broken down into four main parts. 

```{r, eval = F}
function(Adj, t = 1:200, G = Gi, method = CRmod, FuncRes = Fij, K = 1, x.i = .5, yij = 6, eij = 1, xpar = .2, B.o =.5, ext = goExtinct, plot = FALSE){
  require(deSolve)

  grow <- getR(Adj)

  par <- list(
    K = K,
    x.i = x.i,
    yij = yij,
    eij = 1,
    xpar = xpar,
    B.o = B.o,
    r.i = grow,
    A = Adj,
    G.i = G,
    FR = FuncRes
  )

  states <- runif(nrow(Adj), .5, 1)

  out <- ode(y=states, times=t, func=method, parms=par, events = list(func = ext, time = t))

  if(plot) print(matplot(out[,-1], typ = "l", lwd = 2, xlab = "Time", ylab = "Biomass"))

  return(out)
}
```

The first part, `grow <- getR(Adj)` creates a vector of whether or not species are basal. It uses the `getR` function to assess the column sums of the adjacency matrix to determine which species are basal. If there are no basal species, the function will return a warning (_"No basal species in simulation"_). The second part gathers all required parameters of the consumer resource model into a single list. The default values for these parameters are in Table 2. By default the function for growth is `Gi`, functional response is `Fij`, extinction events is `goExtinct`, and the default method is `CRmod`. All species initially start with a random biomass drawn from a uniform distribution between 0.5 and 1.   

```{r table2, results = "asis"}
df <- data.frame(Parameter = factor(c("K", "x.i", "yij", "eij", "xpar", "B.o")), Value = c(1, .5, 6, 1, .2, .5))
kable(df, format = "pandoc", caption = "Fixed parameter values for the dynamic model")
```

The third part of the `CRsimulator` function is the numerical integration using `deSolve::ode`. This integration requires the method function `CRmod`, which codes the bioenergetic model. 

```{r, echo = T, eval = F}
function(t,states,par){

  with(as.list(c(states, par)), {
    dB <- G.i(r = r.i, B = states, K = K) -                                   # growth
      x.i*states +                                                            # death
      rowSums((x.i * yij * FR(states, A, B.o, xpar = xpar) * states)) -       # consumption
      rowSums((x.i * yij * t(FR(states, A, B.o, xpar = xpar)* states))/eij)   # death by predation

    list(c(dB))
  })

}
```

Currently `rend` only has two main types of functional responses: one based on Holling's Type II and Type III (`Fij`),  and a second based on consumer interference (`Fbd`). 

__Fij__
```{r, echo = T, eval = F}
function(B, A, B.0, xpar){
  sum.bk <- rowSums(sapply(1:nrow(A), function(x){B[x] * A[x,]}))^(1+xpar)
  denom <- sum.bk + B.0^(1+xpar)

  F1 <- sapply(1:nrow(A), function(x){(B[x] * A[x,])^(1+xpar)})/denom

  return(F1)
}
```

__Fbd__
```{r, echo = T, eval = F}
function(B, A, B.0, xpar){
  sum.bk <- rowSums(sapply(1:nrow(A), function(x){B[x] * A[x,]}))
  denom <- sum.bk + (1 + (xpar * B)) * B.0

  F1 <- sapply(1:nrow(A), function(x){(B[x] * A[x,])})/denom

  return(F1)
}
```


Both functions take the same input parameters: `B` is the vector of biomasses, `A` is the adjacency matrix, `B.0` is the half saturation constant, and `xpar` is either the _q_ parameter of the Holling functional response or the consumer interference parameter _c_. `Fij` and `Fbd` also both return a matrix reflecting the impact of species _i_ on species _j_.   

The last part of `CRsimulator` will plot the output of the integration (when `plot = TRUE`).  

##	Food Web Dynamics Visualization  

In order to create a visualization of the dynamics of the food web through time, the rend package relies on the animation package. With the current version of rend, the user is able to take the output of the `CRsimulator` function and generate a video representation of the dynamics of the time series. Both biomass and interaction dynamics are visualized. Visualization is done by the `netHTML` function, which serves as a wrapper for the `animation` package's `saveHTML`. The function output is an HTML video of the food web at each time step. 

```{r, echo = T, eval = F}
function(mat, dyn, path1 = getwd()){
  require(animation)

  lay <- matrix(c(layout.sphere(graph.adjacency(mat))[,1], TrophInd(mat)$TL), ncol = 2)
  s <- matrix(0, nrow = nrow(dyn), ncol = ncol(mat))

  ani.options(interval = .25)
  saveHTML(
    {
      for(i in 1:50){
        fr <- Fij(dyn[i,-1], mat, .5, .2)
        strength <- melt(fr)[,3][melt(fr)[,3] > 0]
        fr[fr > 0 ] <- 1

        g.new <- graph.adjacency(t(fr))
        E(g.new)$weight <- strength/max(strength)*10
        s[i,c(which(dyn[i,-1] > 0))] <-log(dyn[i, c(which(dyn[i,] > 0)[-1])]) +
          abs(min(log(dyn[i, c(which(dyn[i,] > 0)[-1])])))

        plot.igraph(g.new, vertex.size = s[i,], edge.width = E(g.new)$weight, layout = lay)
      }
    },
    img.name = paste(path1, "fwdyn", sep = ""), htmlfile = paste(path1, "fwdyn.html", sep = ""),
    interval = .25, nmax =500, ani.width = 500, ani.height = 500, outdir = path1
  )
}
```


#	Examples  

## Two-Species Dynamics (Multiple Functional Response Types)  

A simple example of this package is with two species, a basal resource and a consumer. The adjacency matrix is two rows and two columns.
```{r}
m2sp <- matrix(c(0,0,1,0), nrow = 2, ncol = 2)
m2sp
```

All that is required is to feed this adjacency matrix into the `CRsimulator` function, and choose whether to alter any of the default parameter settings. The first six rows of the output are shown in Table 3. Column one is the time step, column two is the biomass species 1 (the basal species), and column three is the biomass of species 2 (the consumer). The resulting biomass dynamics are shown in Figure 3.   

```{r, echo = T}
my_sim <- CRsimulator(matrix(c(0,0,1,0), nrow = 2, ncol = 2))
```

```{r table3, results = "asis"}
kable(round(head(my_sim), 4), format = "pandoc", caption = "First six rows of the output of the CRsimulator function")
```

```{r fig3, fig.height = 5, fig.width = 6, fig.cap = "The dynamics of consumer and resource given default settings in CRsimulator"}
df1 <- data.frame(x = c(my_sim[,1], my_sim[,1], my_sim[,2]), 
           y = c(my_sim[,2], my_sim[,3], my_sim[,3]), 
           plot = c(rep("Trajectory", 400), rep("State", 200)),
           Species = c(rep(c("A", "B"), each = 200), rep("A", 200)))
ggplot(df1, aes(x = x, y = y, col = Species)) + geom_path(size = 1) + scale_color_manual(values = c("green4", "black", "green4")) + facet_wrap(~plot, scales = "free_x") + theme_bw()
```

Looking at the difference between `Fij` and `Fbd`. 

```{r, echo = T}
my_simbd <- CRsimulator(matrix(c(0,0,1,0), nrow = 2, ncol = 2), FuncRes = Fbd)
```

```{r fig4, fig.height = 5, fig.width = 6, fig.cap = "The dynamics of consumer and resource with differing functional responses given default settings in CRsimulator"}
FRdf <- data.frame(x = rep(1:200, 4), y = c(my_sim[,2], my_sim[,3], my_simbd[,2], my_simbd[,3]),
                   Species = factor(c(rep(c("Resource", "Consumer"), each = 200), rep(c("Resource", "Consumer"), each = 200)), 
                                    levels = c("Resource", "Consumer")),
                   FR = rep(c("Fij", "Fbd"), each = 400))
ggplot(FRdf, aes(x = x, y = y, col = Species)) + geom_path(size = 1) + facet_wrap(~FR, scales = "free_x") + theme_bw() + xlab("Time") + ylab("Biomass")
```

How do the dynamics associated with each functional response type change with altered tuning parameters, _q_ and _c_ respectively. 

```{r, echo = T}
my_sim2 <- CRsimulator(matrix(c(0,0,1,0), nrow = 2, ncol = 2), xpar = 0)
my_sim3 <- CRsimulator(matrix(c(0,0,1,0), nrow = 2, ncol = 2), xpar = 1)
my_sim4 <- CRsimulator(matrix(c(0,0,1,0), nrow = 2, ncol = 2), xpar = 5)


my_sim2bd <- CRsimulator(matrix(c(0,0,1,0), nrow = 2, ncol = 2), FuncRes = Fbd, xpar = 0)
my_sim3bd <- CRsimulator(matrix(c(0,0,1,0), nrow = 2, ncol = 2), FuncRes = Fbd, xpar = 1)
my_sim4bd <- CRsimulator(matrix(c(0,0,1,0), nrow = 2, ncol = 2), FuncRes = Fbd, xpar = 5)
```

```{r fig5, fig.height = 5, fig.width = 6, fig.cap = "The dynamics of consumer and resource given varying xpar settings in CRsimulator"}
df1 <- data.frame(my_sim, xpar = .2, FR = "Fij")
df2 <- data.frame(my_sim2, xpar = 0, FR = "Fij")
df3 <- data.frame(my_sim3, xpar = 1, FR = "Fij")
df4 <- data.frame(my_sim4, xpar = 5, FR = "Fij")

df1bd <- data.frame(my_simbd, xpar = .2, FR = "Fbd")
df2bd <- data.frame(my_sim2bd, xpar = 0, FR = "Fbd")
df3bd <- data.frame(my_sim3bd, xpar = 1, FR = "Fbd")
df4bd <- data.frame(my_sim4bd, xpar = 5, FR = "Fbd")

rdf <- rbindlist(list(df1, df2, df3, df4, df1bd, df2bd, df3bd, df4bd))

ggplot(rdf, aes(x = X1, y = X2, col = factor(xpar))) + geom_path(size = 1, alpha = .7) + scale_color_brewer(palette = "Dark2") + facet_wrap(~FR) + theme_bw() + xlab("Species A") + ylab("Species B") + labs(col = "xpar")
```


## Sample Run of Dynamics on a Niche Model Food Web  

## Food Web Dynamics Explorer via Shiny Web App  

# Conclusions


# Future Directions  

I can see a number of different directions this package could take in terms of increasing performance and functionality. Below I highlight several lines I plan to take in further developing the rend package.  

## Add internal functions for output assessment  

### Structural changes over time  

## Increasing options for trophic dynamic models  

### Ratio-dependent functional responses  

### Non-Bioenergetics models  

## Adding models for alternative interaction types  

### Mutualisms  

### Competition  

## Incorporate Stochasticity  

### sde package  

### Risk-based assessment  

